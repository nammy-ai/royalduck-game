import React, { useEffect, useRef, useState } from "react";

// =============================
// Royal Duck Match (8x8) â€” ä¿®æ­£ç‰ˆ
// ãƒ»ç§»å‹•å›æ•°: 30
// ãƒ»éšœå®³ç‰©: ã‚¢ãƒ’ãƒ«ï¼ˆéš£æ¥ã§3ãƒãƒƒãƒ or 2x2ãƒãƒƒãƒæˆç«‹ã§é™¤å»ï¼‰
// ãƒ»ã‚¹ãƒ†ãƒ¼ã‚¸ã‚’ã‚¯ãƒªã‚¢ã™ã‚‹ã”ã¨ã«ã‚¢ãƒ’ãƒ«ï¼‹1ä½“
// ãƒ»ã‚¹ãƒãƒ›å¯¾å¿œï¼ˆPointer Eventsãƒ™ãƒ¼ã‚¹ / touch-action: noneï¼‰
// ãƒ»å®‰å®šåŒ–: é‡åŠ›ãƒ­ã‚¸ãƒƒã‚¯ã‚’ã‚¢ãƒ’ãƒ«ã§åˆ†æ–­ã€ã‚¤ãƒ™ãƒ³ãƒˆå‘¨ã‚Šã‚’æ•´ç†
// =============================

const GEM_TYPES = [
  // å¼·ã‚ã®ã‚³ãƒ³ãƒˆãƒ©ã‚¹ãƒˆã«èª¿æ•´
  { key: "pink", bg: "from-rose-300 to-pink-500", border: "border-rose-400" },
  { key: "lav",  bg: "from-violet-400 to-fuchsia-500", border: "border-violet-500" },
  { key: "sky",  bg: "from-sky-300 to-blue-500",    border: "border-blue-500" },
  { key: "mint", bg: "from-lime-300 to-emerald-500", border: "border-emerald-500" },
  { key: "sun",  bg: "from-amber-300 to-yellow-400", border: "border-amber-400" },
];

const GRID = 8;
const INITIAL_MOVES = 30;

function makeId() {
  return Math.random().toString(36).slice(2, 9) + Date.now().toString(36).slice(-3);
}

function randomGemKey(excludeKey) {
  let pick;
  do {
    pick = GEM_TYPES[Math.floor(Math.random() * GEM_TYPES.length)].key;
  } while (pick === excludeKey);
  return pick;
}

function cloneBoard(board) {
  return board.map((row) => row.map((c) => (c ? { ...c } : null)));
}

function createBaseBoard() {
  const board = Array.from({ length: GRID }, () => Array(GRID).fill(null));
  for (let r = 0; r < GRID; r++) {
    for (let c = 0; c < GRID; c++) {
      let color = randomGemKey();
      if (c >= 2) {
        const a = board[r][c - 1];
        const b = board[r][c - 2];
        if (a && b && a.kind === "gem" && b.kind === "gem" && a.color === b.color) {
          while (color === a.color) color = randomGemKey(color);
        }
      }
      if (r >= 2) {
        const a = board[r - 1][c];
        const b = board[r - 2][c];
        if (a && b && a.kind === "gem" && b.kind === "gem" && a.color === b.color) {
          while (color === a.color) color = randomGemKey(color);
        }
      }
      board[r][c] = { id: makeId(), kind: "gem", color, popping: false };
    }
  }
  return board;
}

function placeDucks(board, duckCount) {
  const coords = [];
  for (let r = 0; r < GRID; r++) for (let c = 0; c < GRID; c++) coords.push([r, c]);
  for (let i = coords.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [coords[i], coords[j]] = [coords[j], coords[i]];
  }
  let placed = 0;
  const newB = cloneBoard(board);
  for (const [r, c] of coords) {
    if (newB[r][c] && newB[r][c].kind === "gem") {
      newB[r][c] = { id: makeId(), kind: "duck", popping: false };
      placed++;
      if (placed >= duckCount) break;
    }
  }
  return newB;
}

function inBounds(r, c) {
  return r >= 0 && r < GRID && c >= 0 && c < GRID;
}

function areAdjacent(a, b) {
  if (!a || !b) return false;
  return Math.abs(a.r - b.r) + Math.abs(a.c - b.c) === 1;
}

function findMatches(board) {
  const toClear = new Set(); // "r,c"

  // æ¨ªãƒ©ã‚¤ãƒ³ >=3
  for (let r = 0; r < GRID; r++) {
    let streak = 1;
    for (let c = 1; c <= GRID; c++) {
      const curr = c < GRID ? board[r][c] : null;
      const prev = board[r][c - 1];
      const ok = curr && prev && curr.kind === "gem" && prev.kind === "gem" && curr.color === prev.color;
      if (ok) {
        streak++;
      } else {
        if (streak >= 3) {
          for (let k = c - streak; k < c; k++) toClear.add(`${r},${k}`);
        }
        streak = 1;
      }
    }
  }

  // ç¸¦ãƒ©ã‚¤ãƒ³ >=3
  for (let c = 0; c < GRID; c++) {
    let streak = 1;
    for (let r = 1; r <= GRID; r++) {
      const curr = r < GRID ? board[r][c] : null;
      const prev = board[r - 1][c];
      const ok = curr && prev && curr.kind === "gem" && prev.kind === "gem" && curr.color === prev.color;
      if (ok) {
        streak++;
      } else {
        if (streak >= 3) {
          for (let k = r - streak; k < r; k++) toClear.add(`${k},${c}`);
        }
        streak = 1;
      }
    }
  }

  // 2x2 ã‚¹ã‚¯ã‚¨ã‚¢
  for (let r = 0; r < GRID - 1; r++) {
    for (let c = 0; c < GRID - 1; c++) {
      const a = board[r][c];
      const b = board[r][c + 1];
      const d = board[r + 1][c];
      const e = board[r + 1][c + 1];
      if (
        a && b && d && e &&
        a.kind === "gem" && b.kind === "gem" && d.kind === "gem" && e.kind === "gem" &&
        a.color === b.color && a.color === d.color && a.color === e.color
      ) {
        toClear.add(`${r},${c}`);
        toClear.add(`${r},${c + 1}`);
        toClear.add(`${r + 1},${c}`);
        toClear.add(`${r + 1},${c + 1}`);
      }
    }
  }

  return toClear;
}

function findAdjacentDucksToMatches(board, matchSet) {
  const ducksToClear = new Set();
  const dirs = [
    [1, 0],
    [-1, 0],
    [0, 1],
    [0, -1],
  ];
  for (const pos of matchSet) {
    const [r, c] = pos.split(",").map(Number);
    for (const [dr, dc] of dirs) {
      const nr = r + dr,
        nc = c + dc;
      if (inBounds(nr, nc) && board[nr][nc] && board[nr][nc].kind === "duck") {
        ducksToClear.add(`${nr},${nc}`);
      }
    }
  }
  return ducksToClear;
}

// ã‚¢ãƒ’ãƒ«ãŒâ€œå£â€ã¨ã—ã¦æ©Ÿèƒ½ã™ã‚‹é‡åŠ›ãƒ­ã‚¸ãƒƒã‚¯
function applyGravityAndRefill(board) {
  const newB = Array.from({ length: GRID }, () => Array(GRID).fill(null));

  for (let c = 0; c < GRID; c++) {
    // ã¾ãšã‚¢ãƒ’ãƒ«ã®ä½ç½®ã‚’å›ºå®š
    for (let r = 0; r < GRID; r++) {
      const cell = board[r][c];
      if (cell && cell.kind === "duck") newB[r][c] = { ...cell };
    }

    // ä¸‹ã‹ã‚‰é †ã«gemã‚’è½ã¨ã™ï¼ˆduckã‚’é£›ã³è¶Šãˆãªã„ï¼‰
    let write = GRID - 1;
    for (let r = GRID - 1; r >= 0; r--) {
      const cell = board[r][c];
      if (!cell) continue;
      if (cell.kind === "duck") {
        // ãƒ€ãƒƒã‚¯ä½ç½®ã‚’é¿ã‘ã‚‹
        write = r - 1;
      } else if (cell.kind === "gem") {
        // æ¬¡ã®æ›¸ãè¾¼ã¿å…ˆãŒãƒ€ãƒƒã‚¯ãªã‚‰é£›ã°ã™
        while (write >= 0 && newB[write][c] && newB[write][c].kind === "duck") {
          write--;
        }
        if (write >= 0) {
          newB[write][c] = { ...cell, popping: false };
          write--;
        }
      }
    }

    // æ®‹ã‚Šã®ç©ºããƒã‚¹ã‚’æ–°è¦gemã§è£œå……
    for (let r = 0; r < GRID; r++) {
      if (!newB[r][c]) {
        newB[r][c] = { id: makeId(), kind: "gem", color: randomGemKey(), popping: false };
      }
    }
  }
  return newB;
}

function hasPossibleMove(board) {
  const dirs = [
    [1, 0],
    [-1, 0],
    [0, 1],
    [0, -1],
  ];
  for (let r = 0; r < GRID; r++) {
    for (let c = 0; c < GRID; c++) {
      const cell = board[r][c];
      if (!cell || cell.kind !== "gem") continue;
      for (const [dr, dc] of dirs) {
        const nr = r + dr,
          nc = c + dc;
        if (!inBounds(nr, nc)) continue;
        const other = board[nr][nc];
        if (!other || other.kind !== "gem") continue;
        const temp = cloneBoard(board);
        [temp[r][c], temp[nr][nc]] = [temp[nr][nc], temp[r][c]];
        const m = findMatches(temp);
        if (m.size > 0) return true;
      }
    }
  }
  return false;
}

function DuckSVG() {
  return (
    <svg viewBox="0 0 100 70" className="w-3/4 h-3/4 drop-shadow">
      <defs>
        <linearGradient id="duckY" x1="0" y1="0" x2="1" y2="1">
          <stop offset="0%" stopColor="#fde68a" />
          <stop offset="100%" stopColor="#facc15" />
        </linearGradient>
      </defs>
      <ellipse cx="48" cy="44" rx="28" ry="18" fill="url(#duckY)" />
      <path d="M22 45 L14 40 L18 50 Z" fill="#facc15" />
      <circle cx="68" cy="30" r="12" fill="url(#duckY)" />
      <path d="M78 30 Q88 30 88 34 Q78 36 74 33 Z" fill="#fb923c" />
      <circle cx="70" cy="28" r="2.2" fill="#111" />
      <circle cx="64" cy="24" r="3" fill="#fde68a" opacity="0.5" />
    </svg>
  );
}

export default function RoyalDuckMatchFixed() {
  const [stage, setStage] = useState(1);
  const [moves, setMoves] = useState(INITIAL_MOVES);
  const [board, setBoard] = useState(() => placeDucks(createBaseBoard(), 1));
  const [ducksLeft, setDucksLeft] = useState(1);
  const [selected, setSelected] = useState(null); // {r,c}
  const [busy, setBusy] = useState(false);
  const [overlay, setOverlay] = useState(null); // 'clear' | 'gameover' | null

  const downRef = useRef(null); // {r,c,x,y}

  useEffect(() => {
    const duckCount = stage;
    setDucksLeft(duckCount);
    setMoves(INITIAL_MOVES);
    setOverlay(null);
    setBoard(() => {
      let b = placeDucks(createBaseBoard(), duckCount);
      let safety = 40;
      while (!hasPossibleMove(b) && safety-- > 0) b = placeDucks(createBaseBoard(), duckCount);
      return b;
    });
  }, [stage]);

  const trySwap = async (a, b) => {
    if (busy) return;
    if (!a || !b) return;
    if (!areAdjacent(a, b)) return;
    const cellA = board[a.r][a.c];
    const cellB = board[b.r][b.c];
    if (!cellA || !cellB || cellA.kind === "duck" || cellB.kind === "duck") return;

    setBusy(true);
    let temp = cloneBoard(board);
    [temp[a.r][a.c], temp[b.r][b.c]] = [temp[b.r][b.c], temp[a.r][a.c]];

    let matches = findMatches(temp);
    if (matches.size === 0) {
      setSelected(null);
      setBusy(false);
      return;
    }

    setBoard(temp);
    setSelected(null);

    let current = temp;
    let totalClearedDuck = 0;
    let loopGuard = 0;

    while (matches.size > 0 && loopGuard++ < 60) {
      const ducksToClear = findAdjacentDucksToMatches(current, matches);

      const withPop = cloneBoard(current);
      matches.forEach((p) => {
        const [r, c] = p.split(",").map(Number);
        if (withPop[r][c]) withPop[r][c].popping = true;
      });
      ducksToClear.forEach((p) => {
        const [r, c] = p.split(",").map(Number);
        if (withPop[r][c]) withPop[r][c].popping = true;
      });
      setBoard(withPop);

      await new Promise((res) => setTimeout(res, 260));

      const afterClear = cloneBoard(withPop);
      matches.forEach((p) => {
        const [r, c] = p.split(",").map(Number);
        afterClear[r][c] = null;
      });
      ducksToClear.forEach((p) => {
        const [r, c] = p.split(",").map(Number);
        afterClear[r][c] = null;
      });

      totalClearedDuck += ducksToClear.size;

      const collapsed = applyGravityAndRefill(afterClear);
      setBoard(collapsed);
      current = collapsed;

      matches = findMatches(current);
      if (matches.size > 0) {
        await new Promise((res) => setTimeout(res, 120));
      }
    }

    setMoves((m) => m - 1);
    if (totalClearedDuck > 0) setDucksLeft((d) => Math.max(0, d - totalClearedDuck));

    setBusy(false);
  };

  const onCellClick = (r, c) => {
    if (busy) return;
    const cell = board[r][c];
    if (!cell || cell.kind === "duck") return;
    if (!selected) return setSelected({ r, c });
    if (selected.r === r && selected.c === c) return setSelected(null);
    const a = { ...selected };
    const b = { r, c };
    if (!areAdjacent(a, b)) return setSelected({ r, c });
    trySwap(a, b);
  };

  // Pointerãƒ™ãƒ¼ã‚¹ï¼ˆiOS/Android/PCå¯¾å¿œï¼‰
  const onPointerDown = (e, r, c) => {
    if (busy) return;
    const cell = board[r][c];
    if (!cell || cell.kind === "duck") return;
    const x = typeof e.clientX === "number" ? e.clientX : 0;
    const y = typeof e.clientY === "number" ? e.clientY : 0;
    downRef.current = { r, c, x, y };
  };

  const onPointerUp = (e) => {
    if (busy) return;
    const d = downRef.current;
    if (!d) return;
    const upX = typeof e.clientX === "number" ? e.clientX : 0;
    const upY = typeof e.clientY === "number" ? e.clientY : 0;
    const dx = upX - d.x;
    const dy = upY - d.y;
    const adx = Math.abs(dx);
    const ady = Math.abs(dy);
    let target = null;
    if (Math.max(adx, ady) < 12) {
      setSelected({ r: d.r, c: d.c });
      downRef.current = null;
      return;
    }
    if (adx > ady) {
      const c2 = d.c + (dx > 0 ? 1 : -1);
      if (inBounds(d.r, c2)) target = { r: d.r, c: c2 };
    } else {
      const r2 = d.r + (dy > 0 ? 1 : -1);
      if (inBounds(r2, d.c)) target = { r: r2, c: d.c };
    }
    if (target) trySwap({ r: d.r, c: d.c }, target);
    downRef.current = null;
  };

  useEffect(() => {
    if (ducksLeft === 0 && overlay !== "clear") setOverlay("clear");
    else if (moves <= 0 && ducksLeft > 0 && overlay !== "gameover") setOverlay("gameover");
  }, [ducksLeft, moves]);

  const restartStage = () => {
    setOverlay(null);
    setMoves(INITIAL_MOVES);
    setBoard(() => {
      const duckCount = stage;
      let b = placeDucks(createBaseBoard(), duckCount);
      let safety = 40;
      while (!hasPossibleMove(b) && safety-- > 0) b = placeDucks(createBaseBoard(), duckCount);
      return b;
    });
    setDucksLeft(stage);
    setSelected(null);
    setBusy(false);
  };

  const nextStage = () => setStage((s) => s + 1);
  const restartFromStage1 = () => setStage(1);

  const shuffleBoard = () => {
    if (busy) return;
    setBusy(true);
    setTimeout(() => {
      setBoard((prev) => {
        let duckCount = 0;
        for (let r = 0; r < GRID; r++) for (let c = 0; c < GRID; c++) if (prev[r][c]?.kind === "duck") duckCount++;
        let b = placeDucks(createBaseBoard(), duckCount);
        let safety = 40;
        while (!hasPossibleMove(b) && safety-- > 0) b = placeDucks(createBaseBoard(), duckCount);
        return b;
      });
      setSelected(null);
      setBusy(false);
    }, 80);
  };

  return (
    <div className="w-full min-h-screen flex flex-col items-center justify-start bg-gradient-to-b from-white to-sky-50 text-slate-800 pb-8">
      <style>{`
        @keyframes bubblePop { 0% { transform: scale(0.6); opacity: 0.9; filter: blur(0px);} 60% { transform: scale(1.05); opacity: 0.7; filter: blur(0.2px);} 100% { transform: scale(0.4); opacity: 0; filter: blur(1px);} }
        .bubble::after { content: ""; position: absolute; inset: 0; margin: auto; width: 90%; height: 90%; border-radius: 9999px; background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.9), rgba(255,255,255,0.1) 40%, rgba(255,255,255,0.0) 60%), radial-gradient(circle at 70% 70%, rgba(255,255,255,0.5), rgba(255,255,255,0.05) 40%, rgba(255,255,255,0.0) 60%); animation: bubblePop 260ms ease-out forwards; pointer-events: none; }
      `}</style>

      <header className="w-full max-w-[520px] px-4 pt-4 pb-3">
        <div className="flex items-center justify-between gap-2">
          <div className="flex items-center gap-2">
            <div className="text-xs uppercase tracking-widest text-slate-500">Stage</div>
            <div className="text-2xl font-bold">{stage}</div>
          </div>
          <div className="flex items-center gap-4">
            <div className="flex flex-col items-center">
              <div className="text-xs text-slate-500">Ducks</div>
              <div className="flex items-center gap-1">
                <span className="inline-flex items-center justify-center w-6 h-6 rounded-full bg-yellow-200 border border-yellow-300 shadow-sm"><span className="text-[12px]">ğŸ›</span></span>
                <span className="text-xl font-semibold tabular-nums">{ducksLeft}</span>
              </div>
            </div>
            <div className="flex flex-col items-center">
              <div className="text-xs text-slate-500">Moves</div>
              <div className={`text-2xl font-bold tabular-nums ${moves <= 5 ? "text-rose-600" : ""}`}>{moves}</div>
            </div>
          </div>
        </div>
        <p className="mt-2 text-xs text-slate-500 leading-relaxed">
          ã‚¢ãƒ’ãƒ«ã®éš£ã§<em className="not-italic font-semibold">3ã¤ä»¥ä¸Š</em>ã€<span className="font-semibold">ã¾ãŸã¯2Ã—2ã§åŒè‰²4ã¤</span>ã‚’ãã‚ãˆã‚‹ã¨ã€ã‚¢ãƒ’ãƒ«ãŒã‚·ãƒ£ãƒœãƒ³æ³¡ã«ãªã£ã¦æ¶ˆãˆã‚‹ã‚ˆã€‚<br />
          ã‚¿ãƒƒãƒ—2å›ã§å…¥ã‚Œæ›¿ãˆï¼ã‚¹ãƒ¯ã‚¤ãƒ—ã§ã‚‚OKã€‚
        </p>
      </header>

      <div className="w-full max-w-[520px] px-4">
        <div
          className="grid grid-cols-8 gap-1.5 rounded-3xl p-2 bg-white/70 backdrop-blur border border-slate-100 shadow-lg"
          style={{ touchAction: "none" }}
          onPointerUp={onPointerUp}
        >
          {board.map((row, r) =>
            row.map((cell, c) => {
              const isSel = selected && selected.r === r && selected.c === c;
              const baseCls =
                "relative aspect-square rounded-2xl flex items-center justify-center select-none" +
                " transition-transform duration-100 will-change-transform" +
                (isSel ? " ring-4 ring-sky-300 scale-95" : " hover:scale-[0.98]");

              if (!cell) return <div key={`empty-${r}-${c}`} className="aspect-square rounded-2xl bg-slate-50/70" />;

              if (cell.kind === "duck") {
                return (
                  <div key={cell.id} className={baseCls + " bg-gradient-to-br from-yellow-100 to-yellow-200 border border-yellow-300 shadow-inner"}>
                    <DuckSVG />
                  </div>
                );
              }

              const gemDef = GEM_TYPES.find((g) => g.key === cell.color);
              const gemStyle = gemDef?.bg ?? "from-slate-200 to-slate-300";
              const gemBorder = gemDef?.border ?? "border-slate-200";
              return (
                <div
                  key={cell.id}
                  onClick={() => onCellClick(r, c)}
                  onPointerDown={(e) => onPointerDown(e, r, c)}
                  className={
                    baseCls +
                    ` bg-gradient-to-br ${gemStyle} border ${gemBorder} shadow-md overflow-hidden` +
                    (cell.popping ? " bubble" : "")
                  }
                >
                  <div className="absolute inset-0 rounded-2xl pointer-events-none" style={{ boxShadow: "inset 0 6px 12px rgba(255,255,255,0.6)" }} />
                </div>
              );
            })
          )}
        </div>
      </div>

      <div className="w-full max-w-[520px] px-4 mt-4 flex items-center justify-between gap-3">
        <button onClick={shuffleBoard} className="px-4 py-2 rounded-xl bg-white/80 border border-slate-200 shadow hover:shadow-md active:scale-95 text-sm">ã‚·ãƒ£ãƒƒãƒ•ãƒ«</button>
        <div className="flex items-center gap-2">
          <button onClick={restartStage} className="px-4 py-2 rounded-xl bg-white/80 border border-slate-200 shadow hover:shadow-md active:scale-95 text-sm">ä»Šã®ã‚¹ãƒ†ãƒ¼ã‚¸ã‚„ã‚Šç›´ã—</button>
          <button onClick={restartFromStage1} className="px-4 py-2 rounded-xl bg-sky-500 text-white shadow hover:shadow-md active:scale-95 text-sm">ã‚¹ãƒ†ãƒ¼ã‚¸1ã‹ã‚‰</button>
        </div>
      </div>

      {overlay && (
        <div className="fixed inset-0 bg-slate-900/50 backdrop-blur-sm flex items-center justify-center p-6 z-50">
          <div className="w-full max-w-md bg-white rounded-3xl shadow-2xl p-6 text-center">
            {overlay === "clear" ? (
              <>
                <div className="text-3xl font-extrabold text-sky-600">Stage {stage} ã‚¯ãƒªã‚¢ï¼</div>
                <p className="mt-2 text-slate-600">æ¬¡ã®ã‚¹ãƒ†ãƒ¼ã‚¸ã¯ã‚¢ãƒ’ãƒ«ãŒ<span className="font-semibold">+1</span>ä½“å¢—ãˆã‚‹ã‚ˆã€‚</p>
                <div className="mt-5 flex items-center justify-center gap-3">
                  <button onClick={nextStage} className="px-5 py-2.5 rounded-xl bg-sky-500 text-white shadow hover:shadow-md active:scale-95">æ¬¡ã¸ï¼ˆStage {stage + 1}ï¼‰</button>
                  <button onClick={restartStage} className="px-5 py-2.5 rounded-xl bg-white border border-slate-200 shadow hover:shadow-md active:scale-95">ã‚‚ã†ä¸€åº¦</button>
                </div>
              </>
            ) : (
              <>
                <div className="text-3xl font-extrabold text-rose-600">ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼</div>
                <p className="mt-2 text-slate-600">ã‚¢ãƒ’ãƒ«ãŒã¾ã æ®‹ã£ã¦ã„ã¾ã™â€¦ã€‚ã‚‚ã†ä¸€åº¦æŒ‘æˆ¦ã—ã‚ˆã†ï¼</p>
                <div className="mt-5 flex items-center justify-center gap-3">
                  <button onClick={restartStage} className="px-5 py-2.5 rounded-xl bg-rose-500 text-white shadow hover:shadow-md active:scale-95">åŒã˜ã‚¹ãƒ†ãƒ¼ã‚¸ã§å†æŒ‘æˆ¦</button>
                  <button onClick={restartFromStage1} className="px-5 py-2.5 rounded-xl bg-white border border-slate-200 shadow hover:shadow-md active:scale-95">ã‚¹ãƒ†ãƒ¼ã‚¸1ã‹ã‚‰</button>
                </div>
              </>
            )}
          </div>
        </div>
      )}

      <footer className="mt-6 text-[11px] text-slate-400">Â© Royal Duck Match â€“ pastel bubbles</footer>
    </div>
  );
}
